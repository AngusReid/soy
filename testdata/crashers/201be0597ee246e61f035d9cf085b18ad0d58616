{namespacey}{template.}{/template}{template.}{''}{p}{p}{l}{l}{/template}{template.}{p}{l}{n}{r}{t}{b}{b}{literal}F{/literal}{/template}{template.}{print''}{''}{1}{o}{1+o}{T}{L}{/template}/*  {/msg}<br>

  // The 'meaning' attribute is used when you have two messages that are exactly the same string in
  // English, but may be translated to different strings in other languages. The 'meaning' attribute
  // should then be a short string that distinguishes the two strings, and will be used for
  // generating different message ids. The 'meaning' will not be shown to translators, so you must
  // still communicate all the details in the 'desc' text.
  {msg meaning="noun" desc="The word 'Archive' used as a noun, i.e. an information store."}
    Archive
  {/msg}<br>
  {msg meaning="verb" desc="The word 'Archive' used as a verb, i.e. to store information."}
    Archive
  {/msg}<br>

{/template}


/**
 * Demo 'if'.
 * @param pi An approximate value for pi.
 d($pi, 2) == 3.14}
    {msg desc="Example: 3.1416 is a good approximation of pi."}
      {$pi} is a good approximation of pi.
    {/msg}
  {elseif round($pi) == 3}
    {msg desc="Example: 3.1 is a bad approximation of pi."}
      {$pi} is a bad approximation of pi.
    {/msg}
  {else}
    {msg desc="Example: 5 is nowhere near the value of pi."}
      {$pi} is nowhere near the value of pi.
    {/msg}
  {/if}
  <br>
{/template}


/**
 * Demo 'plural'.
 * @param eggs The number of eggs you need to buy
 */
{template.}
{msg desc=""}
{plural$}
{case 1}g{default} {s}s{/plural}
{/msg}
>{/template}


/**.
@param name .
*/
{template.}
r{e};

{switch$}
{case''}
.{case'',''}
.{t}
?{/switch}

>{/template}


/**.
@param persons .
*/
{template.}

{foreach$ in$}

{if (n)}
,{elseif(n)}
,{e}
n{/if}
{p}

{if$==1}
{n}.{e}
{n} {n}.{/if}
>

{y}
>

{/foreach}

{/template}


/**.
@param numLines .
*/
{template.}

{for$ in range()}
e{i+1} {s}>{/for}

{for$ in range(2,0,2)}
{i}.{p}
{/for}
>

{/template}


/**.
@param name .
@param tripInfo .
*/
{template.}

 .{call y./}> //
 {call./}>

 //
  //
  //
 {call. data="l"/}>

 //
 {call. data="o"/}>

{/template}


/**.
@param name .
@param companionName .
@param destinations .
*/
{template.}

{foreach$ in$}

 . //
  //
  //
 {call. data="l"}
{param n:n/}
{/call}>{if (n)%2==0}  //
  //
 {call.}
{param e:$/}
{param n:$/}
{/call}>{/if}

{/foreach}

{/template}


/**.
@param name .
*/
{template.}
 //
 {call.}
{param e:$/}
{param n}
{switch (3)}
{case 0}Boston
        {case 1}Singapore
        {case 2}Zurich
      {/switch}
    {/param}
  {/call}
  <br>
{/template}


/**
 * Private helper for demoCallWithoutParams, demoCallWithParams, and demoCallWithParamBlock.
 * Reports on a trip.
 * @param? name The name of the person who took a trip (optional).
 * @param? destination The destination of the trip (optional).
 */
{template .tripReport_ private="true"}
  // Note: The template name demonstrates the good practice of adding a trailing underscore to
  // private templates (template that should never be called from hand-written code).

  // Note: All parameters to this template are optional. Therefore, below, we must check for
  // "not (hasData() and $name)" rather than simply "not $name" because if absolutely no data is
  // passed, then evaluating "$name" will cause an exception.
  {if not (hasData() and $name)}
    // Note: The message below demonstrates that the 'desc' attribute can be left empty. However,
    // this is not recommended except for the simplest messages, otherwise you risk confusing some
    // translators and getting poor translations.
    {msg desc=""}
      A trip was taken.
    {/msg}
  {elseif not $destination}
    {msg desc="Example: Alice took a trip."}
      {$name} took a trip.
    {/msg}
  {else}
    {msg desc="Example: Alice took a trip to wonderland."}
      {$name} took a trip to {$destination}.
    {/msg}
  {/if}
{/template}


/**
 * Demo {param} blocks with 'kind' attribute.
 * @param message A message text.
 * @param list A list of things.
 */
{template .demoParamWithKindAttribute autoescape="contextual"}
  <div>
    {call .demoParamWithKindAttributeCallee_}
      // Note that the {param} blocks for the message and listItems parameter are declared to have
      // content of kind HTML. This instructs the contextual autoescaper to process the content of
      // these blocks as HTML, and to wrap the the value of the parameter as a soydata.SanitizedHtml
      // object.
      {param message kind="html"}
        <b>{$message}</b>
      {/param}
      {param listItems kind="html"}
        {foreach $i in $list}
          <li>{$i}</li>
        {/foreach}
      {/param}
    {/call}
  </div>
{/template}


/**
 * Demo {param} blocks with 'kind' attribute.
 * @param message A message with HTML markup.
 * @param listItems A HTML-formatted list.
 */
{template .demoParamWithKindAttributeCallee_ private="true" autoescape="contextual"}
  // Note that both $message and $listItems contain HTML markup produced by a {param} block in the
  // the calling template.  Since the {param} blocks are declared to have HTML content, their values
  // are wrapped as soydata.SanitizedHtml objects.  This in turn causes them to be emitted here
  // without further escaping.  In particular, it is not necessary to use the |noAutoescape print
  // directive to prevent double-escaping.
  <div>{$message}</div>
  <ol>
    {$listItems}
  </ol>
{/template}


/**
 * Demo expressions.
 * @param students Nonempty list of students. Each student must have 'name', 'major', and 'year'.
 * @param currentYear The current year.
 */
{template .demoExpressions}

  First student's major: {$students.0.major}<br>
  Last student's year: {$students[length($students) - 1].year}<br>
  Random student's major: {$students[randomInt(length($students))].major}<br>

  {foreach $student in $students}
    {$student.name}:

    {if isFirst($student)}
      {sp}First.
    {elseif isLast($student)}
      {sp}Last.
    // Note: must use floor() in next check since division is floating-point.
    {elseif index($student) == ceiling(length($students) / 2) - 1}
      {sp}Middle.
    {/if}

    {if index($student) % 2 == 1} Even.{/if}
    {sp}{$student.major}.
    {if $student.major == 'Physics' or $student.major == 'Biology'} Scientist.{/if}
    {if $currentYear - $student.year < 10} Young.{/if}

    // The following print statement prints "70s", "80s", "90s", or "00s". Note that "00s" is a
    // special case since using the same expression would yield "0s", not "00s".
    {sp}{$student.year < 2000 ? round($student.year - 1905, -1) + 's' : '0\s'